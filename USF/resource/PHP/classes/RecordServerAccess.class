<?php

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
/** @TODO Needs SERIOUS refactoring **/
/**
 * Description of newPHPClass
 *
 * @author Peter
 */
    class RecordServerAccess {
        private $user          = 'phpServerAccess';
        private $password      = 'ServerLogging';
        private $database      = 'server_meta';
        private $host          = USF_MYSQL_HOST_IP;
        private $dbConnection  = '';
        private $accessArchive = array(
            array('table' => 'access_this_day', 'interval' => 'DAY'),
            array('table' => 'access_last_week','interval' => 'WEEK'),
            array('table' => 'access_last_month','interval' => 'MONTH'),
            array('table' => 'access_last_year','interval' => 'YEAR'),
        );
        private $errorStatus   = false;
        private $errorPacket   = array(
            'action'   => '',
            'method'   => '',
            'message'  => '',
            'severity' => '',
            'script'   => __FILE__,
        );

        function __construct ($webApp, $accessTime, $phpSession, $accessComment, $serializedData) {
            $accessData = array(
                'webApp'        => $webApp,
                'accessTime'    => gmdate('Y-m-d H:i:s', $accessTime),
                'fullRequest'   => $serializedData['url'],
                'phpSession'    => $phpSession,
                'accessComment' => $accessComment,
                'serialServer'  => $serializedData['server'],
                'serialRequest' => $serializedData['request'],
                'serialFiles'   => $serializedData['files'],
            );
            try {
                $this->dbConnection = new PDO("mysql:host=$this->host;dbname=$this->database", $this->user, $this->password);
                $this->dbConnection->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
                $this->RecordAccess($accessData);
            }
            catch(PDOException $pdoError) {
                $this->ProcessError('Initiating Access Recorder', 'PDO', $pdoError->getMessage());
            }
        }

        public function PurgeTables($accessTime) {
            $dateSignature = gmdate('Ymd', $accessTime);
            $purgeLogFile = USF_LOG_DIRECTORY_PHP . $dateSignature . 'purge.log';
            if (!file_exists($purgeLogFile)) {
                $purgeLog = new FileAccess($purgeLogFile, 'create');
                $GLOBALS['initLog']->WriteLine('Created Purge Log File: ' . $purgeLogFile, 'notice');
                foreach ($this->accessArchive as $recordLevel) {
                    $sqlStatement = 'DELETE FROM ' . $recordLevel['table'] . ' where access_time <= now() - interval 12 ' . $recordLevel['interval'];
                    try {
                        $query = $this->dbConnection->prepare($sqlStatement);
                        if ($query !== false) {
                            $result = $query->execute();
                            if ($result) {
                                $removed = $query->rowcount();
                                $purgeLog->WriteLine($dateSignature . '::' . $removed . ' Records removed from table ' . $recordLevel['table']);
                            }
                            else {
                                $this->ProcessError('Executing Purging Query', 'PDO', UsfMethod::CaptureOutput($result));
                            }
                        }
                        else {
                            $this->ProcessError('Preparing Purging Query', 'PDO', UsfMethod::CaptureOutput($query));
                        }
                    }
                    catch (PDOException $pdoError) {
                        $this->ProcessError('Purging Expired Records', 'PDO', $pdoError->getMessage());
                    }
                }
                unset($purgeLog);
            }
            return true;
        }

        public function GetErrorStatus() {
            return $this->errorStatus;
        }

        public function GetErrorPacket() {
            return $this->errorPacket;
        }

        private function RecordAccess($accessData) {
            $tableColumns  = $this->GetTableColumns();
            $columnMarkers = $this->GetQueryMarkers();
            $sqlConstruct  = " ($tableColumns) VALUES ($columnMarkers)";
            foreach ($this->accessArchive as $recordLevel) {
                $sqlStatement = "INSERT INTO " . $recordLevel['table'] . $sqlConstruct;
                try {
                    $query = $this->PrepareQuery($sqlStatement, $recordLevel['table'], 'PDO');
                    if ($query !== false) {
                        $this->ExecuteQuery($query, $accessData, 'PDO');
                    }
                }
                catch (PDOException $pdoError) {
                    $this->ProcessError('Preparing Access Record', 'PDO', $pdoError->getMessage());
                }
            }
        }

        private function PrepareQuery($sqlStatement, $accessAction, $accessType) {
            try {
                $query = $this->dbConnection->prepare($sqlStatement);
            } catch (Exception $pdoError) {
                $this->ProcessError($accessAction, $accessType, $pdoError->getMessage());
             }
            return $query;
        }

        private function ExecuteQuery($query, $accessData, $accessType) {
            try {
                $result = $query->execute($accessData);
            } catch (Exception $pdoError) {
                $reportedError = $pdoError->getMessage();
                $errorInfo = array($reportedError, $query->errorInfo());
                $this->RecordDbError('Access Record Not Inserted', 'INSERT', $query->queryString . ' USING ' . serialize($accessData), serialize($errorInfo));
                $this->ProcessError('Writing Access Record', $accessType, $reportedError);
            }
        }

        private function ReadQuery($sqlStatement) {
            try {
                $result = $this->dbConnection->query($sqlStatement);
                if ($result) {
                    var_dump($result);
                }
            } catch (Exception $pdoError) {
                $this->ProcessError('Selecting Rows', 'PDO', $pdoError->getMessage());
            }
        }

        private function DeleteQuery($sqlStatement) {
            try {
                $query = $this->dbConnection->prepare($sqlStatement);
                $result = $query->execute($sqlStatement);
                if ($result) {
                    return $query->rowcount();
                }
            } catch (Exception $pdoError) {
                $this->ProcessError('Deleting Rows', 'PDO', $pdoError->getMessage());
            }
        }

        /**
        * Errors will always cause a PDO Exception. Updates / Inserts
        * will always return "Rows Affected", which may be 0. Therefor
        * An insert will always have affected rows or an exception! So
        * RecordDbError should be used to record the query / operation that caused the Exception
         * 
         * @param type $accessAction
         * @param type $accessType
         * @param type $sqlStatement
         * @param type $serialisedErrorInfo
         */
        private function RecordDbError($accessAction, $accessType, $sqlStatement, $serialisedErrorInfo) {
            try {
                $query = "INSERT INTO schema_error (access_action, access_type, access_time, query, serialised_error) VALUES ('$accessAction', '$accessType', now(), '$sqlStatement', '$serialisedErrorInfo')";
                $result = $this->dbConnection->exec($query);
            }
            catch (PDOException $pdoError) {
                ProcessErrorEvent($lastError, __LINE__, __METHOD__, $xssCheck);
                $this->ProcessError('Writing Error Record', 'INSERT', $pdoError->getMessage());
            }
        }

        private function ProcessError($accessAction, $actionMethod, $errorInformation, $severity='fatal') {
            $this->errorStatus = true;
            $this->errorPacket['action']  = $accessAction;
            $this->errorPacket['method']  = $actionMethod;
            $this->errorPacket['message'] = $errorInformation;
            $this->errorPacket['severity'] = $severity;
            $this->errorPacket['location'] = 0;
        }

        private function GetTableColumns() {
            /** TODO Should get columns from a Table Definition **/
            return 'web_app, access_time, full_request, php_session, access_comment, server_array, request_array, files_array';
        }

        private function GetQueryMarkers() {
            /** TODO Markers should be "constructed" from the Table Columns **/
            return ':webApp, :accessTime, :fullRequest, :phpSession, :accessComment, :serialServer, :serialRequest, :serialFiles';
        }
    }
