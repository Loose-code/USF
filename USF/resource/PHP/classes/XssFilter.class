<?php
/**
 * Description of XssFilter
 *
 * @author Peter
 */
class XssFilter {
    private $logger = null;
    private $xssDataFile = USF_XSS_DATA_FILE;
    protected $phpSession = false;
    protected $dataToProcess = null;
    protected $xssExceptionList = null;
    protected $knownSchemes = null;
    protected $lastError = false;

    /**
     * Public Method: Creates a new Instance of this Class.
     * 
     * $object = new XssFilter(<i>array</i> $xssData [, <i>boolean</i> $clearSession);
     * 
     * This Class is only expected to be called once and "destroyed" after use.
     * However, to improve performance the Exception List created once and
     * subsequently stored in the PHP Session. If there is no active PHP
     * Session then USF Caution Event will be logged.
     * 
     * @param array $xssData An associated array of the relevant data Globals.
     *      Typically:
     *              'url'     => The full URL,
                    'server'  => Serialized Global $_SERVER,
                    'request' => Serialized Global $_REQUEST,
                    'files'   => Serialized Global $_FILES,
     * 
     * @param boolean [optional] $clearSession If set TRUE it will force the
     *      XSS Exception List to be re-generated.
     * 
     * @return object Returns a single Instance of this Class.
     */
    public function __construct($xssData, $clearSession=false) {
        $this->logger = new Logger('initLog', false);
        if (isset($_SESSION)) {
            $this->phpSession = true;
        }
        else {
            $this->logger->WriteLine('No active PHP Session.', 'notice');
        }
        if ($clearSession === true) {
            $this->phpSession = false;
            $this->logger->WriteLine('PHP Session Data Reset.', 'notice');
        }
        if(!is_array($xssData)) {
            $xssData = array($xssData);
        }
        foreach ($xssData as $key => $value) {
            $xssData[$key] = rawurlencode(rawurldecode($value));
        }
        $this->dataToProcess = implode('|', $xssData);
        $this->xssExceptionList = $this->GetXssExceptionList();
        return $this;
    }

    /**
     * Public Method: Will only allow "approved" Client Request Methods.
     * 
     * $array = $this->ValidRequestMethod( <i>string</i> $_SERVER['REQUEST_METHOD']);
     * 
     * The "approved" Request Methods are "hard coded".
     * 
     * @TODO Consider if there are ANY valid reasons to allow HEAD.
     * 
     * @param string The Client Request Method i.e. GET, HEAD or PUSH etc.
     *   Typically the $_SERVER['REQUEST_METHOD'] Global.
     * 
     * @return array A two element associated array where:
     *   'result' => A <b>string</b> message appropriate for a given <i>status</i>.
     *   'status' => Boolean TRUE if approved FALSE otherwise.
     */
    public function ValidRequestMethod($requestedMethod) {
        $returnData = '';
        $returnStatus = false;
        switch (strtolower($requestedMethod)) {
            case 'get':
            case 'post':
                $returnStatus = true;
                break;
            case 'head':
                $errorData = [1, 'Requested Method (' . $requestedMethod . ') not available.', __LINE__ + 1, 'fatal'];
                $returnStatus = $this->VerifyRequestMethod($requestedMethod);
                break;
            case 'options':
            case 'put':
            case 'trace':
            case 'delete':
            case 'connect':
            default:
                $errorData = [2, 'Requested Method (' . $requestedMethod . ') is inappropriate.', __LINE__, 'fatal'];
        }
        if (!$returnStatus) {
            $returnData = $this->ProcessLocalError($errorData, 'Access Method');
        }
        return ['result' => $returnData, 'status' => $returnStatus];
    }

    /**
     * Private Method: Conceptual functionality.
     * 
     * $boolean = $this->VerifyRequestMethod(<i>string</i> 'HEAD');
     * 
     * The intent is to provide a response to "valid" requests. This method
     * would determine such validity. For the moment all HEAD requests are
     * denied.
     * 
     * @param type $requestedMethod HTTP Request Method.
     * 
     * @return boolean TRUE if valid otherwise FALSE. Currently fixed at FALSE
     */
    private function VerifyRequestMethod($requestedMethod) {
        /** @TODO Add code (TBA) to check it is a valid request **/
        $returnValue = false;
        return $returnValue;
    }

    public function ProcessXss() {
        $signatureMap = array(
            'user' => '@',
            'scheme' => '://',
            'script' => '<',
        );
        foreach ($signatureMap as $thisList => $thisSignature) {
            $signatureCount = $this->CheckForSignature($thisSignature);
            if ($signatureCount === false) {
                $errorPacket = array();
            }
            elseif ($signatureCount > 0) {
                if (!isset($this->knownSchemes)) {
                    $this->knownSchems = $this->GetKnownSchemes();
                }
            }
            {
                $exceptionCount = $this->CheckXssException($thisSignature, $thisList, $signatureCount);
            }
        }
    }

    /**
     * Private Method: Will create a list of excluded XSS Signatures.
     * 
     * $array = $this->GetXssExceptionList();
     * 
     * The are many reasons why there should be perfectly valid XSS Signatures
     * within the data supplied to the Server. The Exception List provides a
     * mechanism for filtering those from the unwanted. To improve performance
     * the list is generated only when the instance is first instantiated. It is
     * then stored in, and retrieved from the PHP Session.
     * 
     * @return array An associated array of acceptable XSS Signatures, by
     * "category". Current categories are:
     *      'scheme' => Signatures that include schemes such as HTTP://,
     *                  HTTPS:// or FTP:// etc.
     *      'self'   => Various "aliases" of the Server thus to avoiding false
     *                  positives when the Server redirects.
     *      'user'   => To avoid false positives when User Authorisation is in
     *                  use and, because it has the same signature, '@'
     *                  "mailto:".
     *      'script' => Identifies the URI's that are "allowed" to upload
     *                  "<script>" content.
     */
    private function GetXssExceptionList() {
        $xssExceptionList = array();
        if (($this->phpSession === true) && (array_key_exists('xssExceptionList', $_SESSION))) {
            $xssExceptionList = $_SESSION['xssExceptionList'];
        }
        else {
            $xssExceptionData = $this->GetXssExceptionData();
            foreach ($xssExceptionData as $category => $categoryArray) {
                $xssExceptionList[$category] = array();
                if (is_array($categoryArray['principal'])) {
                    $principal = $categoryArray['principal'][0];
                }
                else {
                    $principal = $categoryArray['principal'];
                }
                if (!is_array($categoryArray)) {
                    $categoryArray = array($categoryArray);
                }
                foreach ($categoryArray['content'] as $siteArray) {
                    $xssExceptionList[$category][] = $siteArray[$principal];
                }
            }
        }
        if ($this->phpSession === true) {
            $_SESSION['xssExceptionList'] = $xssExceptionList;
        }
        return $xssExceptionList;
    }

    /**
     * Private Method: Converts the JSON XSS Data File into a PHP Array.
     * 
     * $array = $this->GetXssExceptionData();
     * 
     * Using a predefined filename for the XSS JSON Data File <i>xss-exception-list</i>
     * this method will retrieve the USF and the WebApp XSS exception data from
     * predetermined locations. It will convert and merge them into a PHP Array
     * ensuring that it unique values. It will also add a list of Server Aliases
     * as defined at runtime.
     * 
     * @uses JsonData.class
     * 
     * @return array The converted JSON Data as an array og PHP variables.
     */
    private function GetXssExceptionData() {
        $thisWebApp = WebAppFromSession('app');
        $usfXssData = $this->GetJsonData($this->xssDataFile, USF_PHP_INIT_DIRECTORY);
        if ($usfXssData['status'] === false) {
            $usfXssData['result'] = unserialize(USF_XSS_DATA_FILE_STRUCTURE);
            $this->logger->WriteLine('No USF XSS Exception Data', 'notice');
        }
        $webAppInitLocation = UsfMethod::CleanPath(USF_SITE_CONFIG_DIRECTORY_PHP . $thisWebApp);
        $webAppXssData = $this->GetJsonData($this->xssDataFile, $webAppInitLocation);
        if ($webAppXssData['status'] === false) {
            $webAppXssData['result'] = unserialize(USF_XSS_DATA_FILE_STRUCTURE);
            $this->logger->WriteLine('No Web App XSS Exception Data', 'notice');
        }
        $exceptionListData = array_merge_recursive($usfXssData['result']['exceptions'], $webAppXssData['result']['exceptions']);
        $this->AddServerAlias($exceptionListData);
        $exceptionListData = UsfMethod::UniqueArray($exceptionListData);
        return $exceptionListData;
    }

    /**
     * Private Method: Dedicated Method to retrieve and convert XSS JSON Data.
     * 
     * Called by <b>private method</b> <i>GetXssExceptionData()</i> to retrieve
     * and convert the XSS Exception Data JSON File.
     * 
     * $array = $this->GetJsonData(<i>string</i>$xssDataFilename, <i>string</i>xssDataPath);
     * 
     * @param string $xssDataFilename The name of the XSS Exception Data File.
     * 
     * @param string $xssDataPath The absolute OS path to the XSS Exception Data File.
     * 
     * @return array A two element associated array where:
     *   'result' => A <b>string</b> message appropriate for a given <i>status</i>.
     *   'status' => Boolean TRUE if approved FALSE otherwise.
     * 
     * @uses JsonData
     */
    private function GetJsonData($xssDataFilename, $xssDataPath) {
        $returnData = null;
        $returnStatus = null;
        $readJson = JsonData::ReadJsonFile($xssDataFilename, $xssDataPath);
        if ($readJson['status'] === true) {
            $convertJson = JsonData::ConvertJson($readJson['result']);
            if ($convertJson['status'] === true) {
                $returnData = $convertJson['result'];
                $returnStatus = true;
            }
        }
        if (empty($returnData)) {
            $returnData = array();
            $returnStatus = false;
        }
        return ['result' => $returnData, 'status' => $returnStatus];
    }

    /**
     * Private Method: Adds Dynamic XSS Signatures to the configured.
     * 
     * $array = $this->AddServerAlias(<i>array</i>&$exceptionListData);
     * 
     * Normally the XSS Signature Exception list would be managed statically
     * through configuration files. However, some exceptions i.e. the Server
     * Alias, can only be determined whilst the Server is active. This method
     * will merge those "dynamic" signautes with the static ones.
     * 
     * @param array [reference] $exceptionListData XSS Signatures that are part
     * of the Configuration.
     */
    private function AddServerAlias(&$exceptionListData) {
        $lookFor = '://';
        foreach(SERVER_SELF_URI_ALIAS as $serverAlias) {
            if (strpos($serverAlias, $lookFor) === false) {
                $serverAlias = $lookFor . $serverAlias;
            }
            array_push($exceptionListData['scheme']['content'], array('uri' => $serverAlias));
        }
    }

    private function CheckXssException($thisSignature, $thisList, $signatureCount) {
        $returnValue = false;
        $lastError = array(
            'message'  => 'XSS Filter - ' . ucfirst($thisList) . ' Exception Count Error',
            'code'     => 0,
            'severity' => 'fatal',
        );
        $accessData = $this->dataToProcess;
        $thisSignature = rawurlencode(rawurldecode($thisSignature));
        $location = stripos($thisSignature, $accessData);
        if ($location !== false) {
            $location = 0;
        }
        if (isset($lastError)) {
            //ProcessErrorEvent($lastError, __LINE__, __METHOD__, $xssCheck);
            //die('Fatal Error Encountered: XSS Violation');
        }
        return $returnValue;
    }

    /**
     * Private Method: Checks for an XSS Signature in the Server Data.
     * 
     * $interger = $this->CheckForSignature(<i>string</i> $signature);
     * 
     * @param string $signature A literal string representation of a XSS
     * Signature e.g. "@", "<script".
     * 
     * @return integer A count of the number of occurances of the XSS Signature.
     */
    private function CheckForSignature($signature) {
        $pattern = '/' . rawurlencode($signature) . '/';
        $signatureCount = preg_match_all($pattern, $this->dataToProcess);
        return $signatureCount;
    }

    /**
     * Public Method: Returns the current value of <b>property</b> <i>lastError</i>.
     * 
     * $array = $this->GetLastError();
     * 
     * @return array 
     */
    public function GetLastError() {
        return $this->lastError;
    }

    /**
     * Private Method: Will format information about an error.
     * 
     * Given customised indexed array of error information, it will format it
     * into a standardised associated array for use with a Client interface. In
     * this case via the <b>property</b> <i>lastError</i>.
     * 
     * $errorData = [<i>integer</i>$errorCode, <i>string</i>$errorMessage, __LINE__ +/-n, <i>string</i>$severity];
     * $string = $this->ProcessLocalError(<i>array</i>$errorData, __METHOD__);
     * 
     * @param array $errorData An indexed array of error information, where element:
     *   0 => Error Code.
     *   1 => Error Message.
     *   2 => The (approximate) Line Number that the error occurred.
     *   3 => Error Severity.
     * 
     * @param string $callingMethod Typically the result of the <b>magic constant</b>
     * <i>__METHOD__</i> but it can be any "uniquely identifying" text such as
     * <i>Access Method</i>.
     * 
     * @return string Curtsey return of the Error Message.
     */
    private function ProcessLocalError($errorData, $callingMethod) {
        $this->lastError = array(
            'code' => $errorData[0],
            'message' => $errorData[1],
            'location' => $errorData[2],
            'action' => __CLASS__,
            'method' => $callingMethod,
            'severity' => $errorData[3],
        );
        return $errorData[1];
    }
}