<?php

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 * Description of FileAccess
 *
 * @author Peter
 */
class FileAccess {
    private $fileLockRetryCount = USF_FILELOCK_RETRY_COUNT;
    private $fileLockSleepPeriod = USF_FILELOCK_SLEEP_PERIOD;
    private $logger = null;
    private $crudMode = '';
    private $dataWriteBuffer = null;
    private $lastError = '';
    private $currentFile = '';
    private $currentFileObject = false;
    private $messages = array();

    public function __construct($fullFileName, $crud) {
        $this->logger = new Logger('fileLog', false);
        $fileLock = LOCK_EX;
        switch ($crud) {
            case 'create':
                $fileMode = 'wb';
                break;
            case 'read':
                $fileMode = 'rb';
                $fileLock = LOCK_SH;
                break;
            case 'update':
                $fileMode = 'a+b';
                break;
            case 'delete':
                $fileMode = 'cb';
                break;
            default:
                $errorData = [1, 'Invalid CRUD Operation ["' . $crud . '"] for File Operation', __LINE__, 'fatal'];
                $this->ProcessLocalError($errorData, __METHOD__);
        }
        try {
            $this->currentFileObject = new SplFileObject($fullFileName, $fileMode);
            $result = $this->ApplyFileLock($fileLock);
            if ($result) {
                $this->currentFile = $fullFileName;
                $this->crudMode = $crud;
                $this->lastError = '';
            }
            else {
                // Should not get here. Current policy is for the called method to handle
                $this->lastError = $this->messages[] = $this->lastError;
            }
        }
        catch (Exception $thrownError) {
            throw new Exception('Unable to "' . $crud . '" File. System Returns: ' . $thrownError->getMessage());
            /** @TODO Convert to internal Error Handling **/
        }
    }

    /**
     * Magic Method: __destruct() Ensures that any file lock is removed.
     */
    public function __destruct() {
        if (!empty($this->dataWriteBuffer)) {
            $result = $this->WriteBuffer();
            if (!$result) {
                $this->logger->WriteLine('Unable to flush buffer to ' . $this->currentFile, 'error');
            }
        }
        if ($this->currentFileObject) {
            $this->currentFileObject->flock(LOCK_UN);
        }
    }

    private function ApplyFileLock($fileLock='LOCK_UN', $retry=null) {
        if (is_null($retry)) {
            $retry=$this->fileLockRetryCount;
        }
        $result = $this->currentFileObject->flock($fileLock);
        if (!$result) {
            $errorData = [1, 'Unable to Apply ' . $fileLock . ' on File: ' . $this->currentFile, __LINE__ + 1, 'fatal'];
            if ($retry > 0) {
                sleep($this->fileLockSleepPeriod);
                $retry--;
                $result = $this->ApplyFileLock($fileLock, $retry);
            }
            else {
                $this->ProcessLocalError($errorData, __METHOD__);
            }
        }
        return $result;
    }

    public function GetCurrentFileObject() {
        return $this->currentFileObject;
    }

    public function ReadFullFile() {
        $this->currentFileObject->rewind();
        return $this->currentFileObject->fread($this->currentFileObject->getSize());
    }

    private function ProcessLocalError($errorData, $callingMethod) {
        $errorPacket = array(
            'code' => $errorData[0],
            'message' => $errorData[1],
            'location' => $errorData[2],
            'action' => __CLASS__,
            'method' => $callingMethod,
            'severity' => $errorData[3],
        );
        $this->lastError = ProcessErrorEvent($errorPacket);
        return true;
    }

    public function RetryFileLockCount($count=null) {
        if (is_null($count)) {
            $count = $this->fileLockRetryCount;
        }
        elseif (!is_int($count)) {
            $count = USF_FILELOCK_RETRY_COUNT;
        }
        else {
            $count = max(abs($count), 10);
        }
        $this->fileLockRetryCount = $count;
        return $this->fileLockRetryCount;
    }

    public function SleepFileLockPeriod($period=null) {
        if (is_null($period)) {
            $period = $this->fileLockSleepPeriod;
        }
        elseif (!is_int($period)) {
            $period = USF_FILELOCK_SLEEP_PERIOD;
        }
        else {
            $period = max(abs($period), 10);
        }
        $this->fileLockSleepPeriod = $period;
        return $this->fileLockSleepPeriod;
    }
}
